# 코딩 테스트 실력 추적 로그

## 📊 현재 실력 레벨
- **추정 난이도**: 중급 (Queue 자료구조 학습 중, 인덱스 관리 개선 필요)
- **마지막 업데이트**: 2026-01-05
- **종합 점수**: 7.0 / 10

---

## 📝 문제 풀이 기록

### Q20260105 - 프린터 대기열 (2026-01-05) ✅
**문제 유형**: Queue, 시뮬레이션  
**난이도**: 중급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 3차 힌트 후 수정 (4차 제출)
- [X] 최종 정답 도달

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 70% | Queue 필요성 인지 | 시뮬레이션 흐름 이해 |
| 알고리즘 설계 | 50% | 인덱스 추적 방법 미숙 | Map 활용 시도 |
| 초기 구현 | 40% | 인덱스 관리 오류 | 0-based vs 1-based 혼동 |
| 디버깅/수정 | 70% | 3회 수정 끝에 해결 | printNow 로직 수정 |
| 최종 완성 | 100% | 모든 테스트 케이스 통과 | 정답 도달 |

#### 평가 지표
- **초기 접근 정확도**: 5 / 10
  - 문제 해석: 7/10 (Queue 필요성 인지)
  - 알고리즘 선택: 6/10 (Map 활용 아이디어는 좋으나 복잡)
  - 구현 방향: 3/10 (인덱스 관리 미흡)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 3회
  - 1차 힌트 후 개선도: 30% (printNow 로직 일부 수정)
  - 2차 힌트 후 개선도: 60% (compareNow 추가, 로직 개선)
  - 3차 힌트 후 개선도: 100% (location+1로 인덱스 맞춤)

- **시도 횟수**: 4회
  - 논리 오류 수정: 3회 (printNow 업데이트, 인덱스 범위, 비교 대상)
  - 구현 오류 수정: 1회 (poll() 누락)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] 인덱스 추적 (0-based vs 1-based 혼동)
  - [X] 변수 역할 정의 (printNow, compareNow)
  - [X] Queue와 원본 배열 동기화
  - [ ] 자료구조 선택 (Queue는 올바르게 선택)
  - [ ] 시뮬레이션 흐름 이해

- **실수한 부분**:
  - 1차: printNow 업데이트 로직 오류 (poll() 안함)
  - 2차: compareNow 초기값 0으로 설정 (map에 없는 키)
  - 3차: peek()만 하고 poll() 누락
  - 4차: 인덱스 범위 불일치 해결 (location+1) → 정답

- **새로 배운 개념**:
  - Queue의 FIFO 특성과 시뮬레이션 활용
  - 인덱스 추적 방법 (Map 활용)
  - 0-based vs 1-based 인덱싱 주의점
  - peek()와 poll()의 차이 및 활용

#### 개선 제안
- **더 나은 방법**: 배열이나 클래스로 인덱스와 우선순위를 함께 저장
  ```java
  Queue<int[]> queue = new LinkedList<>();
  queue.offer(new int[]{index, priority});
  // 또는
  class Document { int index; int priority; }
  ```
- **장점**: Map 불필요, 코드 간결, 직관적

#### 최종 평가
- **결과**: ✅ 정답 (3회 힌트)
- **소요 시간**: 약 20-25분 추정
- **코드 품질**: 6 / 10 (동작하나 개선 여지 큼)
- **효율성**: 6 / 10 (O(n²) 시간복잡도, 공간복잡도 O(n))
- **종합 점수**: 6.5 / 10

---

### Q20260102 - 괄호 회전하기 (2026-01-02) ✅
**문제 유형**: 스택, 문자열 처리  
**난이도**: 중급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 최종 정답 도달

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 30% | 문자열 회전 개념 누락 | 1차 제출 시 회전 로직 없음 |
| 알고리즘 설계 | 60% | Stack 필요성은 인지, 구현 미숙 | Queue 사용 시도 → Stack으로 변경 |
| 초기 구현 | 40% | 자료구조 선택 오류 | Queue 대신 Stack 사용 필요 |
| 디버깅/수정 | 80% | 엣지 케이스 처리 개선 | isEmpty 체크 추가 |
| 최종 완성 | 100% | 모든 테스트 케이스 통과 | 정답 도달 |

#### 평가 지표
- **초기 접근 정확도**: 4 / 10
  - 문제 해석: 2/10 (문자열 회전 개념 누락)
  - 알고리즘 선택: 4/10 (Queue 선택 → Stack 필요)
  - 구현 방향: 3/10 (올바른 괄호 검사 로직 미흡)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 2회
  - 1차 힌트 후 개선도: 60% (회전 로직 추가, Stack 사용)
  - 2차 힌트 후 개선도: 100% (isEmpty 체크 및 완벽한 구현)

- **시도 횟수**: 3회
  - 논리 오류 수정: 2회 (회전 로직 누락, 괄호 검사 오류)
  - 구현 오류 수정: 1회 (isEmpty 체크 누락)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] 문제 이해 (문자열 회전 개념)
  - [X] 자료구조 활용 (Queue → Stack 전환)
  - [X] 엣지 케이스 처리 (빈 스택 체크)
  - [ ] 알고리즘 선택
  - [ ] 코드 구현

- **실수한 부분**:
  - 1차: 문제에서 "문자열 회전" 요구사항을 놓침, Queue 사용
  - 2차: Stack 사용했으나 isEmpty() 체크 없이 바로 pop() 호출
  - 3차: isEmpty 체크 추가 및 최종 stack 비어있는지 확인 → 정답

- **새로 배운 개념**:
  - 문자열 회전: StringBuilder의 append/delete 활용
  - 올바른 괄호 검사: Stack의 push/pop + isEmpty 체크
  - 엣지 케이스: 빈 스택에서 pop 시도, 스택에 여는 괄호 남은 경우

#### 최종 평가
- **결과**: ✅ 정답 (2회 힌트)
- **소요 시간**: 약 15-20분 추정
- **코드 품질**: 7 / 10 (정상 작동하나 가독성 개선 여지)
- **효율성**: 7 / 10 (O(n²) 시간복잡도, 공간복잡도 O(n))
- **종합 점수**: 7.5 / 10

---

### Q20251231 - 회의실 배정 (2025-12-31)
**문제 유형**: 그리디 알고리즘  
**난이도**: 중급

#### 진행 상황
- [ ] 힌트 없이 독자적 풀이 시도
- [ ] 1차 힌트 후 수정
- [ ] 2차 힌트 후 수정
- [ ] 최종 정답 도달

#### 상세 기록
*기록 필요 - 풀이 완료 시 업데이트*

---

## 📈 실력 변화 추이

### 강점
- 자료구조 선택 능력 향상 (Queue 올바르게 선택)
- 힌트를 통한 개선 능력 (3회 힌트로 정답 도달)
- 문제 해결 끈기 (4번 시도하여 정답 도출)
- 시뮬레이션 흐름 이해도 증가

### 약점
- **인덱스 관리** (0-based vs 1-based 혼동) ⚠️ 주요 개선 포인트
- **변수 역할 명확성** (printNow, compareNow 등 변수 의미 불명확)
- **엣지 케이스 고려** (null 체크, 빈 큐 처리)
- 코드 가독성 및 구조 개선 필요

### 다음 학습 방향
1. **단기 목표**: 인덱스 관리 능력 향상 (0-based 일관성 유지)
2. **중기 목표**: Queue 활용 문제 반복 학습
3. **장기 목표**: 자료구조별 베스트 프랙티스 습득

---

## 🎯 다음 문제 난이도 추천

### 추천 근거
- Q20260105 완료: 6.5/10점 (3회 힌트)
- Q20260102 완료: 7.5/10점 (2회 힌트)
- 평균: 7.0/10점
- 현재 레벨: 중급 (Queue 학습 중)

### 다음 문제 추천
**난이도**: 중급 (현재 난이도 유지)
**유형**: 해시(Hash) 또는 정렬(Sort) 문제
**이유**: 
- Queue는 경험했으므로 다른 자료구조 학습 권장
- 7.0점으로 중급 난이도가 여전히 적절
- 다양한 자료구조를 경험하며 기초 다지기

### 난이도 조정 기준
- **9점 이상 (힌트 없이 완벽 해결)**: 난이도 상승
- **7-8점 (1-2회 힌트로 해결)**: 현재 난이도 유지 ✅
- **5-6점 (2-3회 힌트 필요)**: 유사 난이도 반복 ⚠️
- **4점 이하 (상당한 도움 필요)**: 난이도 하향

---

## 📚 학습 이력

### 완료한 알고리즘
- **스택 (Stack)** - 70% 이해 ✅
  - Q20260102 통과 (7.5/10)
  - 기본 개념: push, pop, isEmpty
  - 응용: 괄호 검사
  - 개선 필요: 엣지 케이스 처리

- **큐 (Queue)** - 60% 이해 ✅
  - Q20260105 통과 (6.5/10)
  - 기본 개념: offer, poll, peek
  - 응용: 시뮬레이션
  - 개선 필요: 인덱스 추적, 데이터 구조 설계

### 학습중
- 그리디 알고리즘 (Q20251231 진행 필요)
- 인덱스 관리 및 변수 설계 능력

### 학습 예정
- 해시 (Hash) - 다음 추천
- 정렬 (Sort)
- DFS/BFS
- 동적 프로그래밍
- 이진 탐색

---

## 📊 문제별 점수 추이
1. Q20260102 (스택): 7.5/10 (2회 힌트)
2. Q20260105 (큐): 6.5/10 (3회 힌트)
- **평균**: 7.0/10
- **추세**: 새로운 자료구조 학습 중 (정상 범위)

---

*이 파일은 문제 풀이 후 자동으로 업데이트됩니다.*
