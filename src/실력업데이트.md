# 코딩 테스트 실력 추적 로그

## 📊 현재 실력 레벨
- **추정 난이도**: 중상급 진입 (힙/우선순위 큐 학습 완료, 알고리즘 설계 능력 우수)
- **마지막 업데이트**: 2026-01-08
- **종합 점수**: 7.2 / 10 ➡️

---

## 📝 문제 풀이 기록

### Q20260108 - 작업 스케줄러 (2026-01-08) ✅
**문제 유형**: 힙(Heap), 우선순위 큐, 시뮬레이션  
**난이도**: 중상급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 3차 힌트 후 최종 코드 제공
- [X] 알고리즘 개념 이해 완료

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 60% | SJF 스케줄링 개념 이해 | 우선순위 큐 필요성 인지 |
| 알고리즘 설계 | 40% | 자료구조 선택 미숙 | List와 PriorityQueue 혼용 |
| 초기 구현 | 30% | 다수의 구현 오류 | 컴파일 에러, 로직 오류 |
| 디버깅/수정 | 50% | 3회 수정 후에도 미해결 | 동시 수정 예외, 로직 구조 문제 |
| 최종 완성 | 100% | 올바른 코드 학습 | 정답 코드로 개념 습득 |

#### 평가 지표
- **초기 접근 정확도**: 4 / 10
  - 문제 해석: 6/10 (SJF 스케줄링 이해)
  - 알고리즘 선택: 5/10 (우선순위 큐 필요성은 인지, 사용법 미숙)
  - 구현 방향: 2/10 (자료구조 활용 및 로직 설계 미흡)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 3회 + 최종 코드 제공
  - 1차 힌트 후 개선도: 20% (문법 오류 일부 수정, 근본적 문제 지속)
  - 2차 힌트 후 개선도: 30% (접근 방향 수정, 여전히 구현 오류)
  - 3차 힌트 후 개선도: 40% (구조 개선 시도, 동시 수정 예외)
  - 최종 코드 제공: 100% (알고리즘 이해 및 학습)

- **시도 횟수**: 3회 (최종 코드 제공)
  - 논리 오류 수정: 3회 (자료구조 활용, 시간 점프 로직, 전체 구조)
  - 구현 오류 수정: 3회 (람다식, 변수 미정의, ConcurrentModificationException)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] 우선순위 큐 활용법 (처음 접하는 자료구조)
  - [X] 시뮬레이션 설계 (현재 시간 관리, 작업 인덱스 관리)
  - [X] 시간 점프 로직 (처리 가능한 작업 없을 때)
  - [X] 정렬과 우선순위 큐 조합
  - [ ] 문제 이해 (대기 시간 계산은 이해함)

- **실수한 부분**:
  - 1차: 변수 미정의, 자료구조 혼용 (int만 저장), ConcurrentModificationException
  - 2차: 람다식 문법 오류, 모든 작업을 처음부터 큐에 추가
  - 3차: for문 안에서 작업 처리, 시간 점프 로직 부재
  - 최종: 올바른 알고리즘 학습 (정렬 + 인덱스 관리 + 우선순위 큐)

- **새로 배운 개념**:
  - 우선순위 큐(PriorityQueue) 기본 사용법
  - Comparator를 이용한 정렬 기준 설정
  - SJF(Shortest Job First) 스케줄링 알고리즘
  - 인덱스와 시간을 함께 관리하는 시뮬레이션 기법
  - 시간 점프 로직 (유휴 시간 처리)
  - Arrays.sort()와 우선순위 큐의 조합

#### 개선 제안
- **학습한 최적 방법**: 
  ```java
  // 1. 정렬로 작업 순서 정리
  Arrays.sort(jobs, (a, b) -> a[0] - b[0]);
  
  // 2. 인덱스와 우선순위 큐로 효율적 관리
  int index = 0;
  PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
  
  // 3. 시간 점프로 유휴 시간 스킵
  if (pq.isEmpty()) currentTime = jobs[index][0];
  ```
- **시간 복잡도**: O(n log n) - 정렬 + 힙 연산
- **공간 복잡도**: O(n) - 우선순위 큐

#### 최종 평가
- **결과**: ✅ 정답 (3회 힌트 + 코드 제공)
- **소요 시간**: 약 25-30분 추정
- **코드 품질**: 학습 단계 (제공된 코드로 개념 습득)
- **효율성**: 10 / 10 (최적 알고리즘 학습)
- **종합 점수**: 6.0 / 10 (난이도 대비 선전, 학습 성과 우수)

---

### Q20260106 - 베스트앨범 (2026-01-06) ✅
**문제 유형**: HashMap, 정렬  
**난이도**: 중급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 최종 정답 도달

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 80% | 그룹화 + 정렬 패턴 인지 | HashMap 필요성 파악 |
| 알고리즘 설계 | 85% | HashMap 2개 사용 전략 | 올바른 자료구조 선택 |
| 초기 구현 | 60% | 문법 오류 및 반환 타입 오류 | 배열 생성 문법 미숙 |
| 디버깅/수정 | 90% | 2회 수정으로 해결 | 세미콜론 실수 |
| 최종 완성 | 100% | 모든 테스트 케이스 통과 | 정답 도달 |

#### 평가 지표
- **초기 접근 정확도**: 7 / 10
  - 문제 해석: 8/10 (그룹화 + 정렬 필요성 인지)
  - 알고리즘 선택: 9/10 (HashMap 올바르게 선택)
  - 구현 방향: 6/10 (문법 오류, 반환 타입 실수)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 2회
  - 1차 힌트 후 개선도: 70% (반환 타입, 배열 생성 문법 수정)
  - 2차 힌트 후 개선도: 100% (세미콜론 제거, 정답 완성)

- **시도 횟수**: 3회
  - 논리 오류 수정: 0회 (알고리즘은 처음부터 올바름)
  - 구현 오류 수정: 2회 (문법, 세미콜론)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] Java 배열 생성 문법 ({} vs new int[]{})
  - [X] if문 세미콜론 실수
  - [ ] 문제 이해 (정확히 파악함)
  - [ ] 자료구조 선택 (HashMap 올바르게 선택)
  - [ ] 알고리즘 설계 (로직 완벽함)

- **실수한 부분**:
  - 1차: 반환 타입 int → int[], 배열 생성 문법 오류
  - 2차: if문 뒤 세미콜론으로 조건문 무효화
  - 3차: 세미콜론 제거 → 정답

- **새로 배운 개념**:
  - HashMap으로 데이터 그룹화
  - 다중 기준 정렬 (Comparator 사용)
  - getOrDefault() 메소드 활용
  - List<int[]> 활용법
  - stream().mapToInt() 변환

#### 개선 제안
- **더 나은 방법**: 매번 정렬하지 않고 데이터 수집 후 한 번만 정렬
  ```java
  // 현재: 곡 추가할 때마다 정렬 (O(n² log n))
  list.add(song);
  Collections.sort(list, ...);
  
  // 개선: 데이터 수집 후 한 번만 정렬 (O(n + m log m))
  list.add(song);
  // ...데이터 수집 완료 후
  for (List<int[]> songList : songs.values()) {
      songList.sort(...);
  }
  ```
- **재생 횟수 같을 때**: 고유 번호 오름차순 조건도 추가 가능
  ```java
  songList.sort((a, b) -> {
      if (b[1] != a[1]) return Integer.compare(b[1], a[1]);
      return Integer.compare(a[0], b[0]);
  });
  ```

#### 최종 평가
- **결과**: ✅ 정답 (2회 힌트)
- **소요 시간**: 약 15-20분 추정
- **코드 품질**: 8 / 10 (로직 우수, 문법 실수만)
- **효율성**: 7 / 10 (작동하나 최적화 여지 있음)
- **종합 점수**: 8.0 / 10 🎉

---

### Q20260105 - 프린터 대기열 (2026-01-05) ✅
**문제 유형**: Queue, 시뮬레이션  
**난이도**: 중급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 3차 힌트 후 수정 (4차 제출)
- [X] 최종 정답 도달

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 70% | Queue 필요성 인지 | 시뮬레이션 흐름 이해 |
| 알고리즘 설계 | 50% | 인덱스 추적 방법 미숙 | Map 활용 시도 |
| 초기 구현 | 40% | 인덱스 관리 오류 | 0-based vs 1-based 혼동 |
| 디버깅/수정 | 70% | 3회 수정 끝에 해결 | printNow 로직 수정 |
| 최종 완성 | 100% | 모든 테스트 케이스 통과 | 정답 도달 |

#### 평가 지표
- **초기 접근 정확도**: 5 / 10
  - 문제 해석: 7/10 (Queue 필요성 인지)
  - 알고리즘 선택: 6/10 (Map 활용 아이디어는 좋으나 복잡)
  - 구현 방향: 3/10 (인덱스 관리 미흡)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 3회
  - 1차 힌트 후 개선도: 30% (printNow 로직 일부 수정)
  - 2차 힌트 후 개선도: 60% (compareNow 추가, 로직 개선)
  - 3차 힌트 후 개선도: 100% (location+1로 인덱스 맞춤)

- **시도 횟수**: 4회
  - 논리 오류 수정: 3회 (printNow 업데이트, 인덱스 범위, 비교 대상)
  - 구현 오류 수정: 1회 (poll() 누락)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] 인덱스 추적 (0-based vs 1-based 혼동)
  - [X] 변수 역할 정의 (printNow, compareNow)
  - [X] Queue와 원본 배열 동기화
  - [ ] 자료구조 선택 (Queue는 올바르게 선택)
  - [ ] 시뮬레이션 흐름 이해

- **실수한 부분**:
  - 1차: printNow 업데이트 로직 오류 (poll() 안함)
  - 2차: compareNow 초기값 0으로 설정 (map에 없는 키)
  - 3차: peek()만 하고 poll() 누락
  - 4차: 인덱스 범위 불일치 해결 (location+1) → 정답

- **새로 배운 개념**:
  - Queue의 FIFO 특성과 시뮬레이션 활용
  - 인덱스 추적 방법 (Map 활용)
  - 0-based vs 1-based 인덱싱 주의점
  - peek()와 poll()의 차이 및 활용

#### 개선 제안
- **더 나은 방법**: 배열이나 클래스로 인덱스와 우선순위를 함께 저장
  ```java
  Queue<int[]> queue = new LinkedList<>();
  queue.offer(new int[]{index, priority});
  // 또는
  class Document { int index; int priority; }
  ```
- **장점**: Map 불필요, 코드 간결, 직관적

#### 최종 평가
- **결과**: ✅ 정답 (3회 힌트)
- **소요 시간**: 약 20-25분 추정
- **코드 품질**: 6 / 10 (동작하나 개선 여지 큼)
- **효율성**: 6 / 10 (O(n²) 시간복잡도, 공간복잡도 O(n))
- **종합 점수**: 6.5 / 10

---

### Q20260102 - 괄호 회전하기 (2026-01-02) ✅
**문제 유형**: 스택, 문자열 처리  
**난이도**: 중급

#### 진행 상황
- [X] 힌트 없이 독자적 풀이 시도 (1차 제출)
- [X] 1차 힌트 후 수정 (2차 제출)
- [X] 2차 힌트 후 수정 (3차 제출)
- [X] 최종 정답 도달

#### 상세 기록
| 단계 | 진행도 | 주요 내용 | 비고 |
|------|--------|-----------|------|
| 문제 이해 | 30% | 문자열 회전 개념 누락 | 1차 제출 시 회전 로직 없음 |
| 알고리즘 설계 | 60% | Stack 필요성은 인지, 구현 미숙 | Queue 사용 시도 → Stack으로 변경 |
| 초기 구현 | 40% | 자료구조 선택 오류 | Queue 대신 Stack 사용 필요 |
| 디버깅/수정 | 80% | 엣지 케이스 처리 개선 | isEmpty 체크 추가 |
| 최종 완성 | 100% | 모든 테스트 케이스 통과 | 정답 도달 |

#### 평가 지표
- **초기 접근 정확도**: 4 / 10
  - 문제 해석: 2/10 (문자열 회전 개념 누락)
  - 알고리즘 선택: 4/10 (Queue 선택 → Stack 필요)
  - 구현 방향: 3/10 (올바른 괄호 검사 로직 미흡)

- **힌트 활용도**: 
  - 힌트 요청 횟수: 2회
  - 1차 힌트 후 개선도: 60% (회전 로직 추가, Stack 사용)
  - 2차 힌트 후 개선도: 100% (isEmpty 체크 및 완벽한 구현)

- **시도 횟수**: 3회
  - 논리 오류 수정: 2회 (회전 로직 누락, 괄호 검사 오류)
  - 구현 오류 수정: 1회 (isEmpty 체크 누락)
  - 최적화 시도: 0회

#### 주요 이슈
- **어려웠던 점**: 
  - [X] 문제 이해 (문자열 회전 개념)
  - [X] 자료구조 활용 (Queue → Stack 전환)
  - [X] 엣지 케이스 처리 (빈 스택 체크)
  - [ ] 알고리즘 선택
  - [ ] 코드 구현

- **실수한 부분**:
  - 1차: 문제에서 "문자열 회전" 요구사항을 놓침, Queue 사용
  - 2차: Stack 사용했으나 isEmpty() 체크 없이 바로 pop() 호출
  - 3차: isEmpty 체크 추가 및 최종 stack 비어있는지 확인 → 정답

- **새로 배운 개념**:
  - 문자열 회전: StringBuilder의 append/delete 활용
  - 올바른 괄호 검사: Stack의 push/pop + isEmpty 체크
  - 엣지 케이스: 빈 스택에서 pop 시도, 스택에 여는 괄호 남은 경우

#### 최종 평가
- **결과**: ✅ 정답 (2회 힌트)
- **소요 시간**: 약 15-20분 추정
- **코드 품질**: 7 / 10 (정상 작동하나 가독성 개선 여지)
- **효율성**: 7 / 10 (O(n²) 시간복잡도, 공간복잡도 O(n))
- **종합 점수**: 7.5 / 10

---

### Q20251231 - 회의실 배정 (2025-12-31)
**문제 유형**: 그리디 알고리즘  
**난이도**: 중급

#### 진행 상황
- [ ] 힌트 없이 독자적 풀이 시도
- [ ] 1차 힌트 후 수정
- [ ] 2차 힌트 후 수정
- [ ] 최종 정답 도달

#### 상세 기록
*기록 필요 - 풀이 완료 시 업데이트*

---

## 📈 실력 변화 추이

### 강점
- ✅ **자료구조 선택 능력 향상** (Queue, HashMap 올바르게 선택)
- ✅ **알고리즘 설계 능력** (논리적 사고 우수, Q20260106에서 입증)
- ✅ **힌트 활용 능력** (평균 2회 힌트로 정답 도달)
- ✅ **문제 해결 끈기** (포기하지 않고 수정 반복)
- ✅ **정렬 이해도** (Comparator 활용 능력)

### 약점
- ⚠️ **Java 문법** (배열 생성, if문 세미콜론 등 사소한 실수)
- ⚠️ **인덱스 관리** (과거 문제에서 개선 필요)
- ⚠️ **변수명 가독성** (t, s 등 짧은 이름 선호)
- ⚠️ **엣지 케이스 고려** (null 체크, 빈 자료구조 처리)
- ⚠️ **코드 최적화** (불필요한 반복 정렬)

### 실력 향상 포인트
- Q20260106: **알고리즘 로직은 완벽**, 문법 실수만 수정
- Q20260105 대비: 논리 오류 0회 → 큰 발전!
- HashMap 활용 능력 확보

### 다음 학습 방향
1. **단기 목표**: Java 기본 문법 숙지 (배열, if문, 세미콜론)
2. **중기 목표**: 코드 가독성 향상 (변수명, 주석)
3. **장기 목표**: 시간복잡도 최적화 의식

---

## 🎯 다음 문제 난이도 추천

### 추천 근거
- Q20260102 완료: 7.5/10점 (2회 힌트)
- Q20260105 완료: 6.5/10점 (3회 힌트)
- Q20260106 완료: 8.0/10점 (2회 힌트) 🆕
- **평균**: 7.3/10점 ⬆️
- **현재 레벨**: 중급+ (알고리즘 사고력 우수, 구현 능력 향상 중)

### 다음 문제 추천
**난이도**: 중급 (힙 복습) 또는 중급+ (그리디)
**유형**: 힙(Heap) 복습 문제 또는 그리디(Greedy) 알고리즘
**이유**: 
- Q20260108에서 힙 개념 학습 완료 → 비슷한 난이도 힙 문제로 복습 추천
- 또는 그리디 알고리즘으로 새로운 패러다임 학습
- HashMap, 정렬 능력은 우수하므로 새로운 영역 확장 가능

### 난이도 조정 기준
- **9점 이상 (힌트 없이 완벽 해결)**: 난이도 상승
- **7-8점 (1-2회 힌트로 해결)**: 현재 난이도 유지 또는 소폭 상승 ✅
- **5-6점 (2-3회 힌트 필요)**: 유사 난이도 반복
- **4점 이하 (상당한 도움 필요)**: 난이도 하향

**결론**: 다음 문제는 **중급 힙 복습** 또는 **중급+ 그리디** 권장!

---

## 📚 학습 이력

### 완료한 알고리즘
- **스택 (Stack)** - 70% 이해 ✅
  - Q20260102 통과 (7.5/10)
  - 기본 개념: push, pop, isEmpty
  - 응용: 괄호 검사
  - 개선 필요: 엣지 케이스 처리

- **큐 (Queue)** - 60% 이해 ✅
  - Q20260105 통과 (6.5/10)
  - 기본 개념: offer, poll, peek
  - 응용: 시뮬레이션
  - 개선 필요: 인덱스 추적, 데이터 구조 설계

- **해시 (HashMap)** - 85% 이해 🎉 ✅
  - Q20260106 통과 (8.0/10)
  - 기본 개념: put, get, getOrDefault, keySet
  - 응용: 데이터 그룹화, 다중 기준 정렬
  - 개선 필요: 효율성 최적화 (불필요한 반복 정렬 제거)

- **힙 (Heap) / 우선순위 큐** - 60% 이해 🆕 ✅
  - Q20260108 통과 (6.0/10)
  - 기본 개념: PriorityQueue, offer, poll, peek
  - 응용: SJF 스케줄링, 시뮬레이션
  - 개선 필요: 자료구조 활용 숙달, 시뮬레이션 설계 능력

### 학습중
- Java 기본 문법 (배열 생성, 조건문)
- 정렬 알고리즘 (Comparator, Comparable)
- 변수명 및 코드 가독성

### 학습 예정
- 힙 (Heap) / 우선순위 큐 - 추가 연습 필요 (기본 개념 학습 완료)
- 그리디 알고리즘 - 다음 추천 🎯
- DFS/BFS
- 동적 프로그래밍
- 이진 탐색
- 투 포인터

---

## 📊 문제별 점수 추이
1. Q20260102 (스택): 7.5/10 (2회 힌트)
2. Q20260105 (큐): 6.5/10 (3회 힌트)
3. Q20260106 (해시): 8.0/10 (2회 힌트)
4. Q20260108 (힙): 6.0/10 (3회 힌트 + 코드 제공) 🆕
- **평균**: 7.0/10 ➡️
- **추세**: 새로운 자료구조 학습 중! 기본기 다지기 단계 📚

---

## 💡 종합 평가

### 성장 하이라이트
**Q20260106 (HashMap)**에서 알고리즘 로직을 처음부터 완벽하게 설계했습니다!
- HashMap 2개 사용 전략 ✅
- 데이터 그룹화 로직 ✅
- 정렬 전략 ✅
- 상위 2개 선택 로직 ✅

**Q20260108 (힙)**에서 새로운 자료구조를 학습했습니다!
- 우선순위 큐 개념 습득 ✅
- SJF 스케줄링 알고리즘 이해 ✅
- 시뮬레이션 설계 패턴 학습 ✅

**문제별 비교:**
- Q20260105: 논리 오류 3회
- Q20260106: 논리 오류 0회 (알고리즘 완벽) 🎉
- Q20260108: 논리 오류 3회 (새로운 개념 학습)

**결론**: 익숙한 자료구조는 완벽하게 다룰 수 있으나, 새로운 개념은 추가 연습 필요!

### 개선 필요 영역
- Java 기본 문법 숙지 (람다식, 제네릭)
- 새로운 자료구조 학습 시 기본 사용법 숙달
- 시뮬레이션 설계 능력 (시간 관리, 인덱스 관리)
- 코드 최적화 의식
- 변수명 가독성

---

*이 파일은 문제 풀이 후 자동으로 업데이트됩니다.*
