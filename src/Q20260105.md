# Q20260105 - 프린터 대기열

## 📋 문제 설명

일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다.

이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 프린터는 다음과 같은 방식으로 동작합니다.

1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 확인합니다.
2. 대기목록에 J보다 중요도가 높은 문서가 한 개라도 존재하면, J를 대기목록의 가장 마지막으로 보냅니다.
3. 그렇지 않으면 J를 인쇄합니다.

예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 `2 1 3 2` 라면 `C → D → A → B` 순으로 인쇄됩니다.

내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C(3)를 요청했다면 1번째로, A(2)를 요청했다면 3번째로 인쇄됩니다.

## 📥 입력

- `priorities`: 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열
  - 크기: 1 이상 100 이하
  - 원소: 1 이상 9 이하의 정수
- `location`: 내가 인쇄를 요청한 문서의 위치 (0부터 시작)
  - 범위: 0 이상 (대기목록 크기 - 1) 이하

## 📤 출력

내가 요청한 문서가 몇 번째로 인쇄되는지 return 합니다.

## 💡 예시

### 예시 1
```
입력: priorities = [2, 1, 3, 2], location = 2
출력: 1
설명: C(중요도 3)가 가장 먼저 인쇄됩니다.
```

### 예시 2
```
입력: priorities = [1, 1, 9, 1, 1, 1], location = 0
출력: 5
설명: 
- 처음 상태: [1, 1, 9, 1, 1, 1]
- 9가 가장 먼저 인쇄
- 나머지 1들이 순서대로 인쇄되므로, 첫 번째 문서는 5번째로 인쇄
```

### 예시 3
```
입력: priorities = [2, 1, 2, 1, 2], location = 3
출력: 5
설명:
- 중요도 2인 문서들이 먼저 인쇄: 0번 → 2번 → 4번
- 그 다음 중요도 1인 문서들: 1번 → 3번
- 따라서 3번 위치 문서는 5번째로 인쇄
```

## 🎯 제약 사항

- 시간 복잡도: O(n²) 이내로 해결하세요
- Java 표준 라이브러리의 Queue 인터페이스 사용을 권장합니다
- 문서를 추적하기 위한 방법을 고민해보세요 (힌트: 인덱스 정보 유지)

## 📝 Solution 클래스

```java
class Solution {
    public int solution(int[] priorities, int location) {
        // 여기에 코드를 작성하세요
        
    }
}
```

## ✅ 테스트 케이스

```java
public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        // 테스트 1
        int result1 = sol.solution(new int[]{2, 1, 3, 2}, 2);
        System.out.println(result1); // 예상: 1
        
        // 테스트 2
        int result2 = sol.solution(new int[]{1, 1, 9, 1, 1, 1}, 0);
        System.out.println(result2); // 예상: 5
        
        // 테스트 3
        int result3 = sol.solution(new int[]{2, 1, 2, 1, 2}, 3);
        System.out.println(result3); // 예상: 5
    }
}
```

---

**문제 난이도**: 중급  
**주요 개념**: Queue, 시뮬레이션, 자료구조 활용  
**작성일**: 2026-01-05

> 💡 **Tip**: 문서의 "원래 위치"를 어떻게 추적할지가 핵심입니다!
